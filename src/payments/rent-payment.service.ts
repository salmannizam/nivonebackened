import { Injectable, BadRequestException, ForbiddenException, Logger, Inject, forwardRef } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { RentPayment, RentPaymentDocument } from './schemas/rent-payment.schema';
import { ResidentDocument } from '../residents/schemas/resident.schema';
import { BedsService } from '../beds/beds.service';

@Injectable()
export class RentPaymentService {
  private readonly logger = new Logger(RentPaymentService.name);

  constructor(
    @InjectModel(RentPayment.name)
    private rentPaymentModel: Model<RentPaymentDocument>,
    @Inject(forwardRef(() => BedsService))
    private bedsService: BedsService,
  ) {}

  /**
   * Transform payment response to include roomNumber and bedNumber
   */
  private transformPaymentResponse(payment: any) {
    const paymentObj = payment.toObject ? payment.toObject() : payment;
    const resident = paymentObj.residentId as any;
    const bed = paymentObj.bedId as any;
    
    // Get room number from bed's roomId or resident's roomId
    let roomNumber = null;
    if (bed?.roomId) {
      roomNumber = bed.roomId.roomNumber || bed.roomId;
    } else if (resident?.roomId) {
      roomNumber = resident.roomId.roomNumber || resident.roomId;
    }
    
    // Get bed number from bed or resident's bedId
    let bedNumber = null;
    if (bed?.bedNumber) {
      bedNumber = bed.bedNumber;
    } else if (resident?.bedId?.bedNumber) {
      bedNumber = resident.bedId.bedNumber;
    }
    
    return {
      ...paymentObj,
      residentName: resident?.name || null,
      residentPhone: resident?.phone || null,
      roomNumber: roomNumber,
      bedNumber: bedNumber,
      residentId: resident?._id || paymentObj.residentId,
      bedId: bed?._id || paymentObj.bedId,
    };
  }

  /**
   * Auto-generate rent payment for a resident for a given month
   * Called by cron job, not by admin
   * 
   * IMPORTANT: Rent is sourced from Bed.rent ONLY - this is the single source of truth
   */
  async generateRentPayment(
    tenantId: string,
    resident: ResidentDocument,
    month: string,
    dueDate: Date,
  ): Promise<RentPaymentDocument> {
    // Bed assignment is REQUIRED - rent comes from bed.rent only
    if (!resident.bedId) {
      throw new BadRequestException('Resident must be assigned to a bed. Rent is calculated from bed rent only.');
    }

    // Get bed to retrieve rent (source of truth)
    const bedObjectId = resident.bedId instanceof Types.ObjectId 
      ? resident.bedId 
      : new Types.ObjectId(String(resident.bedId));
    
    const bed = await this.bedsService.findOne(bedObjectId.toString(), tenantId);
    
    if (!bed || !bed.rent || bed.rent <= 0) {
      throw new BadRequestException(`Bed does not have a valid rent amount. Bed rent is required for billing.`);
    }

    // Convert IDs to ObjectId if needed
    const tenantObjectId = typeof tenantId === 'string' 
      ? new Types.ObjectId(tenantId) 
      : tenantId;
    const residentObjectId = resident._id instanceof Types.ObjectId 
      ? resident._id 
      : new Types.ObjectId(String(resident._id));

    // Check if payment already exists
    const existing = await this.rentPaymentModel.findOne({
      tenantId: tenantObjectId,
      residentId: residentObjectId,
      month,
    });

    if (existing) {
      return existing; // Return existing payment
    }

    // Determine initial status based on due date
    const now = new Date();
    let initialStatus = 'DUE';
    if (dueDate > now) {
      initialStatus = 'UPCOMING'; // Payment is due in the future
    } else if (dueDate < now) {
      initialStatus = 'OVERDUE'; // Payment is past due
    }

    // Create new rent payment using bed.rent (source of truth)
    const rentPayment = new this.rentPaymentModel({
      tenantId: tenantObjectId,
      residentId: residentObjectId,
      bedId: bedObjectId,
      month,
      amountDue: bed.rent, // Use bed.rent - the single source of truth
      amountPaid: 0,
      dueDate,
      status: initialStatus,
      isAutoGenerated: true,
    });

    return rentPayment.save();
  }

  /**
   * Get all rent payments for a tenant
   */
  async findAll(
    tenantId: string,
    filters?: {
      residentId?: string;
      status?: string;
      month?: string;
      monthFrom?: string;
      monthTo?: string;
      dueDateFrom?: Date;
      dueDateTo?: Date;
      search?: string;
    },
  ) {
    if (!tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    
    let tenantObjectId: Types.ObjectId;
    try {
      tenantObjectId = typeof tenantId === 'string' 
        ? new Types.ObjectId(tenantId) 
        : tenantId;
    } catch (error) {
      throw new BadRequestException('Invalid tenant ID format');
    }
    
    const query: any = { tenantId: tenantObjectId };
    if (filters?.residentId) {
      query.residentId = typeof filters.residentId === 'string' 
        ? new Types.ObjectId(filters.residentId) 
        : filters.residentId;
    }
    if (filters?.status) {
      query.status = filters.status;
    }
    if (filters?.month) {
      query.month = filters.month;
    }
    if (filters?.monthFrom || filters?.monthTo) {
      query.month = {};
      if (filters.monthFrom) {
        query.month.$gte = filters.monthFrom;
      }
      if (filters.monthTo) {
        query.month.$lte = filters.monthTo;
      }
    }
    if (filters?.dueDateFrom || filters?.dueDateTo) {
      query.dueDate = {};
      if (filters.dueDateFrom) {
        query.dueDate.$gte = filters.dueDateFrom;
      }
      if (filters.dueDateTo) {
        query.dueDate.$lte = filters.dueDateTo;
      }
    }
    
    try {
      let payments = await this.rentPaymentModel
        .find(query)
        .populate({
          path: 'residentId',
          select: 'name phone roomId bedId',
          populate: [
            { path: 'roomId', select: 'roomNumber' },
            { path: 'bedId', select: 'bedNumber roomId', populate: { path: 'roomId', select: 'roomNumber' } }
          ]
        })
        .populate({
          path: 'bedId',
          select: 'bedNumber roomId',
          populate: { path: 'roomId', select: 'roomNumber' }
        })
        .sort({ month: -1 })
        .exec();
      
      // Apply search filter (resident name, month)
      if (filters?.search) {
        const searchLower = filters.search.toLowerCase();
        payments = payments.filter((p: any) => {
          const paymentObj = p.toObject ? p.toObject() : p;
          const resident = paymentObj.residentId as any;
          return (
            resident?.name?.toLowerCase().includes(searchLower) ||
            paymentObj.month?.toLowerCase().includes(searchLower)
          );
        });
      }
      
      // Transform to include roomNumber and bedNumber
      return payments.map((payment: any) => this.transformPaymentResponse(payment));
    } catch (error) {
      this.logger.error('Error fetching rent payments:', error);
      throw new BadRequestException('Failed to fetch rent payments');
    }
  }

  /**
   * Get rent payment by ID
   */
  async findOne(id: string, tenantId: string) {
    const tenantObjectId = typeof tenantId === 'string' 
      ? new Types.ObjectId(tenantId) 
      : tenantId;
    const payment = await this.rentPaymentModel
      .findOne({ _id: id, tenantId: tenantObjectId })
      .populate({
        path: 'residentId',
        select: 'name phone roomId bedId',
        populate: [
          { path: 'roomId', select: 'roomNumber' },
          { path: 'bedId', select: 'bedNumber roomId', populate: { path: 'roomId', select: 'roomNumber' } }
        ]
      })
      .populate({
        path: 'bedId',
        select: 'bedNumber roomId',
        populate: { path: 'roomId', select: 'roomNumber' }
      })
      .exec();

    if (!payment) {
      throw new BadRequestException('Rent payment not found');
    }

    return this.transformPaymentResponse(payment);
  }

  /**
   * Mark payment as PAID or PARTIAL
   * Only payment status fields can be updated
   */
  async updatePaymentStatus(
    id: string,
    tenantId: string,
    updateData: {
      amountPaid: number;
      paidDate?: Date;
      paymentMode?: string;
      notes?: string;
    },
  ) {
    const tenantObjectId = typeof tenantId === 'string' 
      ? new Types.ObjectId(tenantId) 
      : tenantId;
    
    const payment = await this.rentPaymentModel.findOne({ _id: id, tenantId: tenantObjectId });
    if (!payment) {
      throw new BadRequestException('Rent payment not found');
    }

    const amountPaid = updateData.amountPaid ?? 0;
    let status = 'DUE';
    if (amountPaid >= payment.amountDue) {
      status = 'PAID';
    } else if (amountPaid > 0) {
      status = 'PARTIAL';
    }

    const updated = await this.rentPaymentModel
      .findByIdAndUpdate(
        id,
        {
          amountPaid,
          status,
          paidDate: updateData.paidDate || (status === 'PAID' ? new Date() : undefined),
          paymentMode: updateData.paymentMode,
          notes: updateData.notes,
        },
        { new: true },
      )
      .populate({
        path: 'residentId',
        select: 'name phone roomId bedId',
        populate: [
          { path: 'roomId', select: 'roomNumber' },
          { path: 'bedId', select: 'bedNumber roomId', populate: { path: 'roomId', select: 'roomNumber' } }
        ]
      })
      .populate({
        path: 'bedId',
        select: 'bedNumber roomId',
        populate: { path: 'roomId', select: 'roomNumber' }
      })
      .exec();

    return this.transformPaymentResponse(updated);
  }

  /**
   * Get payments due today
   */
  async getDueToday(tenantId: string) {
    if (!tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    
    let tenantObjectId: Types.ObjectId;
    try {
      tenantObjectId = typeof tenantId === 'string' 
        ? new Types.ObjectId(tenantId) 
        : tenantId;
    } catch (error) {
      throw new BadRequestException('Invalid tenant ID format');
    }
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    try {
      const payments = await this.rentPaymentModel
        .find({
          tenantId: tenantObjectId,
          dueDate: { $gte: today, $lt: tomorrow },
          status: { $in: ['DUE', 'PARTIAL'] },
        })
        .populate({
          path: 'residentId',
          select: 'name phone roomId bedId',
          populate: [
            { path: 'roomId', select: 'roomNumber' },
            { path: 'bedId', select: 'bedNumber roomId', populate: { path: 'roomId', select: 'roomNumber' } }
          ]
        })
        .populate({
          path: 'bedId',
          select: 'bedNumber roomId',
          populate: { path: 'roomId', select: 'roomNumber' }
        })
        .exec();
      
      return payments.map((p: any) => this.transformPaymentResponse(p));
    } catch (error) {
      this.logger.error('Error fetching payments due today:', error);
      throw new BadRequestException('Failed to fetch payments due today');
    }
  }

  /**
   * Get payments due in next 7 days
   */
  async getDueInNext7Days(tenantId: string) {
    if (!tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    
    let tenantObjectId: Types.ObjectId;
    try {
      tenantObjectId = typeof tenantId === 'string' 
        ? new Types.ObjectId(tenantId) 
        : tenantId;
    } catch (error) {
      throw new BadRequestException('Invalid tenant ID format');
    }
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const nextWeek = new Date(today);
    nextWeek.setDate(nextWeek.getDate() + 7);

    try {
      const payments = await this.rentPaymentModel
        .find({
          tenantId: tenantObjectId,
          dueDate: { $gte: today, $lte: nextWeek },
          status: { $in: ['DUE', 'PARTIAL'] },
        })
        .populate({
          path: 'residentId',
          select: 'name phone roomId bedId',
          populate: [
            { path: 'roomId', select: 'roomNumber' },
            { path: 'bedId', select: 'bedNumber roomId', populate: { path: 'roomId', select: 'roomNumber' } }
          ]
        })
        .populate({
          path: 'bedId',
          select: 'bedNumber roomId',
          populate: { path: 'roomId', select: 'roomNumber' }
        })
        .exec();
      
      return payments.map((p: any) => this.transformPaymentResponse(p));
    } catch (error) {
      this.logger.error('Error fetching payments due in next 7 days:', error);
      throw new BadRequestException('Failed to fetch payments due in next 7 days');
    }
  }

  /**
   * Get overdue payments
   */
  async getOverdue(tenantId: string) {
    if (!tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    
    let tenantObjectId: Types.ObjectId;
    try {
      tenantObjectId = typeof tenantId === 'string' 
        ? new Types.ObjectId(tenantId) 
        : tenantId;
    } catch (error) {
      throw new BadRequestException('Invalid tenant ID format');
    }
    const now = new Date();
    try {
      const payments = await this.rentPaymentModel
        .find({
          tenantId: tenantObjectId,
          dueDate: { $lt: now },
          status: { $in: ['DUE', 'PARTIAL', 'OVERDUE'] },
        })
        .populate({
          path: 'residentId',
          select: 'name phone roomId bedId',
          populate: [
            { path: 'roomId', select: 'roomNumber' },
            { path: 'bedId', select: 'bedNumber roomId', populate: { path: 'roomId', select: 'roomNumber' } }
          ]
        })
        .populate({
          path: 'bedId',
          select: 'bedNumber roomId',
          populate: { path: 'roomId', select: 'roomNumber' }
        })
        .exec();
      
      return payments.map((p: any) => this.transformPaymentResponse(p));
    } catch (error) {
      this.logger.error('Error fetching overdue payments:', error);
      throw new BadRequestException('Failed to fetch overdue payments');
    }
  }

  /**
   * Update overdue status for all payments
   * Called by cron job
   */
  async updateOverdueStatus(tenantId: string) {
    if (!tenantId) {
      return;
    }
    
    let tenantObjectId: Types.ObjectId;
    try {
      tenantObjectId = typeof tenantId === 'string' 
        ? new Types.ObjectId(tenantId) 
        : tenantId;
    } catch (error) {
      return;
    }
    
    const now = new Date();
    const todayStart = new Date(now);
    todayStart.setHours(0, 0, 0, 0);
    const todayEnd = new Date(todayStart);
    todayEnd.setDate(todayEnd.getDate() + 1);
    
    try {
      // Update UPCOMING to DUE if due date is today
      await this.rentPaymentModel.updateMany(
        {
          tenantId: tenantObjectId,
          dueDate: { $gte: todayStart, $lt: todayEnd },
          status: 'UPCOMING',
        },
        { $set: { status: 'DUE' } },
      );
      
      // Update DUE/PARTIAL/UPCOMING to OVERDUE if past due date
      await this.rentPaymentModel.updateMany(
        {
          tenantId: tenantObjectId,
          dueDate: { $lt: now },
          status: { $in: ['DUE', 'PARTIAL', 'UPCOMING'] },
        },
        { $set: { status: 'OVERDUE' } },
      );
    } catch (error) {
      this.logger.error('Error updating overdue status:', error);
    }
  }

  /**
   * Get pending payment summary
   */
  async getPendingSummary(tenantId: string) {
    if (!tenantId) {
      throw new BadRequestException('Tenant ID is required');
    }
    
    let tenantObjectId: Types.ObjectId;
    try {
      tenantObjectId = typeof tenantId === 'string' 
        ? new Types.ObjectId(tenantId) 
        : tenantId;
    } catch (error) {
      throw new BadRequestException('Invalid tenant ID format');
    }
    try {
      const pending = await this.rentPaymentModel
        .find({
          tenantId: tenantObjectId,
          status: { $in: ['DUE', 'PARTIAL', 'OVERDUE'] },
        })
        .exec();

      const totalAmount = pending.reduce((sum, p) => {
        return sum + (p.amountDue - p.amountPaid);
      }, 0);

      return {
        count: pending.length,
        totalAmount,
      };
    } catch (error) {
      this.logger.error('Error fetching pending summary:', error);
      throw new BadRequestException('Failed to fetch pending summary');
    }
  }

  /**
   * Remove rent payment (FORBIDDEN - rent payments cannot be deleted)
   */
  async remove(id: string, tenantId: string) {
    throw new ForbiddenException('Rent payments cannot be deleted');
  }
}
